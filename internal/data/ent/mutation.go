// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"
	"yayar/internal/data/ent/app"
	"yayar/internal/data/ent/history"
	"yayar/internal/data/ent/predicate"
	"yayar/internal/data/ent/user"
	"yayar/internal/data/ent/version"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApp     = "App"
	TypeHistory = "History"
	TypeUser    = "User"
	TypeVersion = "Version"
)

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op              Op
	typ             string
	id              *int
	bundle_id       *string
	name            *string
	logo            *string
	latest_version  *string
	createdAt       *time.Time
	updatedAt       *time.Time
	clearedFields   map[string]struct{}
	user            map[int]struct{}
	removeduser     map[int]struct{}
	cleareduser     bool
	versions        map[int]struct{}
	removedversions map[int]struct{}
	clearedversions bool
	done            bool
	oldValue        func(context.Context) (*App, error)
	predicates      []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id int) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().App.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBundleID sets the "bundle_id" field.
func (m *AppMutation) SetBundleID(s string) {
	m.bundle_id = &s
}

// BundleID returns the value of the "bundle_id" field in the mutation.
func (m *AppMutation) BundleID() (r string, exists bool) {
	v := m.bundle_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBundleID returns the old "bundle_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldBundleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBundleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBundleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBundleID: %w", err)
	}
	return oldValue.BundleID, nil
}

// ResetBundleID resets all changes to the "bundle_id" field.
func (m *AppMutation) ResetBundleID() {
	m.bundle_id = nil
}

// SetName sets the "name" field.
func (m *AppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppMutation) ResetName() {
	m.name = nil
}

// SetLogo sets the "logo" field.
func (m *AppMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *AppMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ResetLogo resets all changes to the "logo" field.
func (m *AppMutation) ResetLogo() {
	m.logo = nil
}

// SetLatestVersion sets the "latest_version" field.
func (m *AppMutation) SetLatestVersion(s string) {
	m.latest_version = &s
}

// LatestVersion returns the value of the "latest_version" field in the mutation.
func (m *AppMutation) LatestVersion() (r string, exists bool) {
	v := m.latest_version
	if v == nil {
		return
	}
	return *v, true
}

// OldLatestVersion returns the old "latest_version" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldLatestVersion(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatestVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatestVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatestVersion: %w", err)
	}
	return oldValue.LatestVersion, nil
}

// ClearLatestVersion clears the value of the "latest_version" field.
func (m *AppMutation) ClearLatestVersion() {
	m.latest_version = nil
	m.clearedFields[app.FieldLatestVersion] = struct{}{}
}

// LatestVersionCleared returns if the "latest_version" field was cleared in this mutation.
func (m *AppMutation) LatestVersionCleared() bool {
	_, ok := m.clearedFields[app.FieldLatestVersion]
	return ok
}

// ResetLatestVersion resets all changes to the "latest_version" field.
func (m *AppMutation) ResetLatestVersion() {
	m.latest_version = nil
	delete(m.clearedFields, app.FieldLatestVersion)
}

// SetCreatedAt sets the "createdAt" field.
func (m *AppMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *AppMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *AppMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *AppMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *AppMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *AppMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *AppMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *AppMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AppMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *AppMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *AppMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *AppMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AppMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddVersionIDs adds the "versions" edge to the Version entity by ids.
func (m *AppMutation) AddVersionIDs(ids ...int) {
	if m.versions == nil {
		m.versions = make(map[int]struct{})
	}
	for i := range ids {
		m.versions[ids[i]] = struct{}{}
	}
}

// ClearVersions clears the "versions" edge to the Version entity.
func (m *AppMutation) ClearVersions() {
	m.clearedversions = true
}

// VersionsCleared reports if the "versions" edge to the Version entity was cleared.
func (m *AppMutation) VersionsCleared() bool {
	return m.clearedversions
}

// RemoveVersionIDs removes the "versions" edge to the Version entity by IDs.
func (m *AppMutation) RemoveVersionIDs(ids ...int) {
	if m.removedversions == nil {
		m.removedversions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.versions, ids[i])
		m.removedversions[ids[i]] = struct{}{}
	}
}

// RemovedVersions returns the removed IDs of the "versions" edge to the Version entity.
func (m *AppMutation) RemovedVersionsIDs() (ids []int) {
	for id := range m.removedversions {
		ids = append(ids, id)
	}
	return
}

// VersionsIDs returns the "versions" edge IDs in the mutation.
func (m *AppMutation) VersionsIDs() (ids []int) {
	for id := range m.versions {
		ids = append(ids, id)
	}
	return
}

// ResetVersions resets all changes to the "versions" edge.
func (m *AppMutation) ResetVersions() {
	m.versions = nil
	m.clearedversions = false
	m.removedversions = nil
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.bundle_id != nil {
		fields = append(fields, app.FieldBundleID)
	}
	if m.name != nil {
		fields = append(fields, app.FieldName)
	}
	if m.logo != nil {
		fields = append(fields, app.FieldLogo)
	}
	if m.latest_version != nil {
		fields = append(fields, app.FieldLatestVersion)
	}
	if m.createdAt != nil {
		fields = append(fields, app.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, app.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldBundleID:
		return m.BundleID()
	case app.FieldName:
		return m.Name()
	case app.FieldLogo:
		return m.Logo()
	case app.FieldLatestVersion:
		return m.LatestVersion()
	case app.FieldCreatedAt:
		return m.CreatedAt()
	case app.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldBundleID:
		return m.OldBundleID(ctx)
	case app.FieldName:
		return m.OldName(ctx)
	case app.FieldLogo:
		return m.OldLogo(ctx)
	case app.FieldLatestVersion:
		return m.OldLatestVersion(ctx)
	case app.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case app.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldBundleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBundleID(v)
		return nil
	case app.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case app.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	case app.FieldLatestVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatestVersion(v)
		return nil
	case app.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case app.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(app.FieldLatestVersion) {
		fields = append(fields, app.FieldLatestVersion)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	switch name {
	case app.FieldLatestVersion:
		m.ClearLatestVersion()
		return nil
	}
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldBundleID:
		m.ResetBundleID()
		return nil
	case app.FieldName:
		m.ResetName()
		return nil
	case app.FieldLogo:
		m.ResetLogo()
		return nil
	case app.FieldLatestVersion:
		m.ResetLatestVersion()
		return nil
	case app.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case app.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, app.EdgeUser)
	}
	if m.versions != nil {
		edges = append(edges, app.EdgeVersions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.versions))
		for id := range m.versions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser != nil {
		edges = append(edges, app.EdgeUser)
	}
	if m.removedversions != nil {
		edges = append(edges, app.EdgeVersions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.removedversions))
		for id := range m.removedversions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, app.EdgeUser)
	}
	if m.clearedversions {
		edges = append(edges, app.EdgeVersions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	switch name {
	case app.EdgeUser:
		return m.cleareduser
	case app.EdgeVersions:
		return m.clearedversions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	switch name {
	case app.EdgeUser:
		m.ResetUser()
		return nil
	case app.EdgeVersions:
		m.ResetVersions()
		return nil
	}
	return fmt.Errorf("unknown App edge %s", name)
}

// HistoryMutation represents an operation that mutates the History nodes in the graph.
type HistoryMutation struct {
	config
	op             Op
	typ            string
	id             *int
	device         *string
	ip             *string
	createdAt      *time.Time
	clearedFields  map[string]struct{}
	version        map[int]struct{}
	removedversion map[int]struct{}
	clearedversion bool
	done           bool
	oldValue       func(context.Context) (*History, error)
	predicates     []predicate.History
}

var _ ent.Mutation = (*HistoryMutation)(nil)

// historyOption allows management of the mutation configuration using functional options.
type historyOption func(*HistoryMutation)

// newHistoryMutation creates new mutation for the History entity.
func newHistoryMutation(c config, op Op, opts ...historyOption) *HistoryMutation {
	m := &HistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHistoryID sets the ID field of the mutation.
func withHistoryID(id int) historyOption {
	return func(m *HistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *History
		)
		m.oldValue = func(ctx context.Context) (*History, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().History.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHistory sets the old History of the mutation.
func withHistory(node *History) historyOption {
	return func(m *HistoryMutation) {
		m.oldValue = func(context.Context) (*History, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HistoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().History.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDevice sets the "device" field.
func (m *HistoryMutation) SetDevice(s string) {
	m.device = &s
}

// Device returns the value of the "device" field in the mutation.
func (m *HistoryMutation) Device() (r string, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDevice returns the old "device" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldDevice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevice: %w", err)
	}
	return oldValue.Device, nil
}

// ResetDevice resets all changes to the "device" field.
func (m *HistoryMutation) ResetDevice() {
	m.device = nil
}

// SetIP sets the "ip" field.
func (m *HistoryMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *HistoryMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *HistoryMutation) ResetIP() {
	m.ip = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *HistoryMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *HistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *HistoryMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// AddVersionIDs adds the "version" edge to the Version entity by ids.
func (m *HistoryMutation) AddVersionIDs(ids ...int) {
	if m.version == nil {
		m.version = make(map[int]struct{})
	}
	for i := range ids {
		m.version[ids[i]] = struct{}{}
	}
}

// ClearVersion clears the "version" edge to the Version entity.
func (m *HistoryMutation) ClearVersion() {
	m.clearedversion = true
}

// VersionCleared reports if the "version" edge to the Version entity was cleared.
func (m *HistoryMutation) VersionCleared() bool {
	return m.clearedversion
}

// RemoveVersionIDs removes the "version" edge to the Version entity by IDs.
func (m *HistoryMutation) RemoveVersionIDs(ids ...int) {
	if m.removedversion == nil {
		m.removedversion = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.version, ids[i])
		m.removedversion[ids[i]] = struct{}{}
	}
}

// RemovedVersion returns the removed IDs of the "version" edge to the Version entity.
func (m *HistoryMutation) RemovedVersionIDs() (ids []int) {
	for id := range m.removedversion {
		ids = append(ids, id)
	}
	return
}

// VersionIDs returns the "version" edge IDs in the mutation.
func (m *HistoryMutation) VersionIDs() (ids []int) {
	for id := range m.version {
		ids = append(ids, id)
	}
	return
}

// ResetVersion resets all changes to the "version" edge.
func (m *HistoryMutation) ResetVersion() {
	m.version = nil
	m.clearedversion = false
	m.removedversion = nil
}

// Where appends a list predicates to the HistoryMutation builder.
func (m *HistoryMutation) Where(ps ...predicate.History) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *HistoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (History).
func (m *HistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HistoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.device != nil {
		fields = append(fields, history.FieldDevice)
	}
	if m.ip != nil {
		fields = append(fields, history.FieldIP)
	}
	if m.createdAt != nil {
		fields = append(fields, history.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case history.FieldDevice:
		return m.Device()
	case history.FieldIP:
		return m.IP()
	case history.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case history.FieldDevice:
		return m.OldDevice(ctx)
	case history.FieldIP:
		return m.OldIP(ctx)
	case history.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown History field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case history.FieldDevice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevice(v)
		return nil
	case history.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case history.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown History field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown History numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HistoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HistoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown History nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HistoryMutation) ResetField(name string) error {
	switch name {
	case history.FieldDevice:
		m.ResetDevice()
		return nil
	case history.FieldIP:
		m.ResetIP()
		return nil
	case history.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown History field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.version != nil {
		edges = append(edges, history.EdgeVersion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case history.EdgeVersion:
		ids := make([]ent.Value, 0, len(m.version))
		for id := range m.version {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedversion != nil {
		edges = append(edges, history.EdgeVersion)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HistoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case history.EdgeVersion:
		ids := make([]ent.Value, 0, len(m.removedversion))
		for id := range m.removedversion {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedversion {
		edges = append(edges, history.EdgeVersion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case history.EdgeVersion:
		return m.clearedversion
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HistoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown History unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HistoryMutation) ResetEdge(name string) error {
	switch name {
	case history.EdgeVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown History edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	email           *string
	password        *string
	token           *string
	createdAt       *time.Time
	updatedAt       *time.Time
	clearedFields   map[string]struct{}
	apps            map[int]struct{}
	removedapps     map[int]struct{}
	clearedapps     bool
	versions        map[int]struct{}
	removedversions map[int]struct{}
	clearedversions bool
	done            bool
	oldValue        func(context.Context) (*User, error)
	predicates      []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetToken sets the "token" field.
func (m *UserMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *UserMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *UserMutation) ResetToken() {
	m.token = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *UserMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// AddAppIDs adds the "apps" edge to the App entity by ids.
func (m *UserMutation) AddAppIDs(ids ...int) {
	if m.apps == nil {
		m.apps = make(map[int]struct{})
	}
	for i := range ids {
		m.apps[ids[i]] = struct{}{}
	}
}

// ClearApps clears the "apps" edge to the App entity.
func (m *UserMutation) ClearApps() {
	m.clearedapps = true
}

// AppsCleared reports if the "apps" edge to the App entity was cleared.
func (m *UserMutation) AppsCleared() bool {
	return m.clearedapps
}

// RemoveAppIDs removes the "apps" edge to the App entity by IDs.
func (m *UserMutation) RemoveAppIDs(ids ...int) {
	if m.removedapps == nil {
		m.removedapps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.apps, ids[i])
		m.removedapps[ids[i]] = struct{}{}
	}
}

// RemovedApps returns the removed IDs of the "apps" edge to the App entity.
func (m *UserMutation) RemovedAppsIDs() (ids []int) {
	for id := range m.removedapps {
		ids = append(ids, id)
	}
	return
}

// AppsIDs returns the "apps" edge IDs in the mutation.
func (m *UserMutation) AppsIDs() (ids []int) {
	for id := range m.apps {
		ids = append(ids, id)
	}
	return
}

// ResetApps resets all changes to the "apps" edge.
func (m *UserMutation) ResetApps() {
	m.apps = nil
	m.clearedapps = false
	m.removedapps = nil
}

// AddVersionIDs adds the "versions" edge to the Version entity by ids.
func (m *UserMutation) AddVersionIDs(ids ...int) {
	if m.versions == nil {
		m.versions = make(map[int]struct{})
	}
	for i := range ids {
		m.versions[ids[i]] = struct{}{}
	}
}

// ClearVersions clears the "versions" edge to the Version entity.
func (m *UserMutation) ClearVersions() {
	m.clearedversions = true
}

// VersionsCleared reports if the "versions" edge to the Version entity was cleared.
func (m *UserMutation) VersionsCleared() bool {
	return m.clearedversions
}

// RemoveVersionIDs removes the "versions" edge to the Version entity by IDs.
func (m *UserMutation) RemoveVersionIDs(ids ...int) {
	if m.removedversions == nil {
		m.removedversions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.versions, ids[i])
		m.removedversions[ids[i]] = struct{}{}
	}
}

// RemovedVersions returns the removed IDs of the "versions" edge to the Version entity.
func (m *UserMutation) RemovedVersionsIDs() (ids []int) {
	for id := range m.removedversions {
		ids = append(ids, id)
	}
	return
}

// VersionsIDs returns the "versions" edge IDs in the mutation.
func (m *UserMutation) VersionsIDs() (ids []int) {
	for id := range m.versions {
		ids = append(ids, id)
	}
	return
}

// ResetVersions resets all changes to the "versions" edge.
func (m *UserMutation) ResetVersions() {
	m.versions = nil
	m.clearedversions = false
	m.removedversions = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.token != nil {
		fields = append(fields, user.FieldToken)
	}
	if m.createdAt != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldToken:
		return m.Token()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldToken:
		return m.OldToken(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldToken:
		m.ResetToken()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.apps != nil {
		edges = append(edges, user.EdgeApps)
	}
	if m.versions != nil {
		edges = append(edges, user.EdgeVersions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeApps:
		ids := make([]ent.Value, 0, len(m.apps))
		for id := range m.apps {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.versions))
		for id := range m.versions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedapps != nil {
		edges = append(edges, user.EdgeApps)
	}
	if m.removedversions != nil {
		edges = append(edges, user.EdgeVersions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeApps:
		ids := make([]ent.Value, 0, len(m.removedapps))
		for id := range m.removedapps {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.removedversions))
		for id := range m.removedversions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapps {
		edges = append(edges, user.EdgeApps)
	}
	if m.clearedversions {
		edges = append(edges, user.EdgeVersions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeApps:
		return m.clearedapps
	case user.EdgeVersions:
		return m.clearedversions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeApps:
		m.ResetApps()
		return nil
	case user.EdgeVersions:
		m.ResetVersions()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VersionMutation represents an operation that mutates the Version nodes in the graph.
type VersionMutation struct {
	config
	op               Op
	typ              string
	id               *int
	version          *string
	build            *int
	addbuild         *int
	apk_size         *float64
	addapk_size      *float64
	ipa_size         *float64
	addipa_size      *float64
	ipa_url          *string
	apk_url          *string
	plist_url        *string
	description      *string
	access           *string
	access_code      *string
	status           *int
	addstatus        *int
	createdAt        *time.Time
	updatedAt        *time.Time
	clearedFields    map[string]struct{}
	user             map[int]struct{}
	removeduser      map[int]struct{}
	cleareduser      bool
	app              map[int]struct{}
	removedapp       map[int]struct{}
	clearedapp       bool
	histories        map[int]struct{}
	removedhistories map[int]struct{}
	clearedhistories bool
	done             bool
	oldValue         func(context.Context) (*Version, error)
	predicates       []predicate.Version
}

var _ ent.Mutation = (*VersionMutation)(nil)

// versionOption allows management of the mutation configuration using functional options.
type versionOption func(*VersionMutation)

// newVersionMutation creates new mutation for the Version entity.
func newVersionMutation(c config, op Op, opts ...versionOption) *VersionMutation {
	m := &VersionMutation{
		config:        c,
		op:            op,
		typ:           TypeVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVersionID sets the ID field of the mutation.
func withVersionID(id int) versionOption {
	return func(m *VersionMutation) {
		var (
			err   error
			once  sync.Once
			value *Version
		)
		m.oldValue = func(ctx context.Context) (*Version, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Version.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVersion sets the old Version of the mutation.
func withVersion(node *Version) versionOption {
	return func(m *VersionMutation) {
		m.oldValue = func(context.Context) (*Version, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Version.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *VersionMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *VersionMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *VersionMutation) ResetVersion() {
	m.version = nil
}

// SetBuild sets the "build" field.
func (m *VersionMutation) SetBuild(i int) {
	m.build = &i
	m.addbuild = nil
}

// Build returns the value of the "build" field in the mutation.
func (m *VersionMutation) Build() (r int, exists bool) {
	v := m.build
	if v == nil {
		return
	}
	return *v, true
}

// OldBuild returns the old "build" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldBuild(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuild is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuild requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuild: %w", err)
	}
	return oldValue.Build, nil
}

// AddBuild adds i to the "build" field.
func (m *VersionMutation) AddBuild(i int) {
	if m.addbuild != nil {
		*m.addbuild += i
	} else {
		m.addbuild = &i
	}
}

// AddedBuild returns the value that was added to the "build" field in this mutation.
func (m *VersionMutation) AddedBuild() (r int, exists bool) {
	v := m.addbuild
	if v == nil {
		return
	}
	return *v, true
}

// ResetBuild resets all changes to the "build" field.
func (m *VersionMutation) ResetBuild() {
	m.build = nil
	m.addbuild = nil
}

// SetApkSize sets the "apk_size" field.
func (m *VersionMutation) SetApkSize(f float64) {
	m.apk_size = &f
	m.addapk_size = nil
}

// ApkSize returns the value of the "apk_size" field in the mutation.
func (m *VersionMutation) ApkSize() (r float64, exists bool) {
	v := m.apk_size
	if v == nil {
		return
	}
	return *v, true
}

// OldApkSize returns the old "apk_size" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldApkSize(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApkSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApkSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApkSize: %w", err)
	}
	return oldValue.ApkSize, nil
}

// AddApkSize adds f to the "apk_size" field.
func (m *VersionMutation) AddApkSize(f float64) {
	if m.addapk_size != nil {
		*m.addapk_size += f
	} else {
		m.addapk_size = &f
	}
}

// AddedApkSize returns the value that was added to the "apk_size" field in this mutation.
func (m *VersionMutation) AddedApkSize() (r float64, exists bool) {
	v := m.addapk_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearApkSize clears the value of the "apk_size" field.
func (m *VersionMutation) ClearApkSize() {
	m.apk_size = nil
	m.addapk_size = nil
	m.clearedFields[version.FieldApkSize] = struct{}{}
}

// ApkSizeCleared returns if the "apk_size" field was cleared in this mutation.
func (m *VersionMutation) ApkSizeCleared() bool {
	_, ok := m.clearedFields[version.FieldApkSize]
	return ok
}

// ResetApkSize resets all changes to the "apk_size" field.
func (m *VersionMutation) ResetApkSize() {
	m.apk_size = nil
	m.addapk_size = nil
	delete(m.clearedFields, version.FieldApkSize)
}

// SetIpaSize sets the "ipa_size" field.
func (m *VersionMutation) SetIpaSize(f float64) {
	m.ipa_size = &f
	m.addipa_size = nil
}

// IpaSize returns the value of the "ipa_size" field in the mutation.
func (m *VersionMutation) IpaSize() (r float64, exists bool) {
	v := m.ipa_size
	if v == nil {
		return
	}
	return *v, true
}

// OldIpaSize returns the old "ipa_size" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldIpaSize(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIpaSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIpaSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIpaSize: %w", err)
	}
	return oldValue.IpaSize, nil
}

// AddIpaSize adds f to the "ipa_size" field.
func (m *VersionMutation) AddIpaSize(f float64) {
	if m.addipa_size != nil {
		*m.addipa_size += f
	} else {
		m.addipa_size = &f
	}
}

// AddedIpaSize returns the value that was added to the "ipa_size" field in this mutation.
func (m *VersionMutation) AddedIpaSize() (r float64, exists bool) {
	v := m.addipa_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearIpaSize clears the value of the "ipa_size" field.
func (m *VersionMutation) ClearIpaSize() {
	m.ipa_size = nil
	m.addipa_size = nil
	m.clearedFields[version.FieldIpaSize] = struct{}{}
}

// IpaSizeCleared returns if the "ipa_size" field was cleared in this mutation.
func (m *VersionMutation) IpaSizeCleared() bool {
	_, ok := m.clearedFields[version.FieldIpaSize]
	return ok
}

// ResetIpaSize resets all changes to the "ipa_size" field.
func (m *VersionMutation) ResetIpaSize() {
	m.ipa_size = nil
	m.addipa_size = nil
	delete(m.clearedFields, version.FieldIpaSize)
}

// SetIpaURL sets the "ipa_url" field.
func (m *VersionMutation) SetIpaURL(s string) {
	m.ipa_url = &s
}

// IpaURL returns the value of the "ipa_url" field in the mutation.
func (m *VersionMutation) IpaURL() (r string, exists bool) {
	v := m.ipa_url
	if v == nil {
		return
	}
	return *v, true
}

// OldIpaURL returns the old "ipa_url" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldIpaURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIpaURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIpaURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIpaURL: %w", err)
	}
	return oldValue.IpaURL, nil
}

// ClearIpaURL clears the value of the "ipa_url" field.
func (m *VersionMutation) ClearIpaURL() {
	m.ipa_url = nil
	m.clearedFields[version.FieldIpaURL] = struct{}{}
}

// IpaURLCleared returns if the "ipa_url" field was cleared in this mutation.
func (m *VersionMutation) IpaURLCleared() bool {
	_, ok := m.clearedFields[version.FieldIpaURL]
	return ok
}

// ResetIpaURL resets all changes to the "ipa_url" field.
func (m *VersionMutation) ResetIpaURL() {
	m.ipa_url = nil
	delete(m.clearedFields, version.FieldIpaURL)
}

// SetApkURL sets the "apk_url" field.
func (m *VersionMutation) SetApkURL(s string) {
	m.apk_url = &s
}

// ApkURL returns the value of the "apk_url" field in the mutation.
func (m *VersionMutation) ApkURL() (r string, exists bool) {
	v := m.apk_url
	if v == nil {
		return
	}
	return *v, true
}

// OldApkURL returns the old "apk_url" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldApkURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApkURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApkURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApkURL: %w", err)
	}
	return oldValue.ApkURL, nil
}

// ClearApkURL clears the value of the "apk_url" field.
func (m *VersionMutation) ClearApkURL() {
	m.apk_url = nil
	m.clearedFields[version.FieldApkURL] = struct{}{}
}

// ApkURLCleared returns if the "apk_url" field was cleared in this mutation.
func (m *VersionMutation) ApkURLCleared() bool {
	_, ok := m.clearedFields[version.FieldApkURL]
	return ok
}

// ResetApkURL resets all changes to the "apk_url" field.
func (m *VersionMutation) ResetApkURL() {
	m.apk_url = nil
	delete(m.clearedFields, version.FieldApkURL)
}

// SetPlistURL sets the "plist_url" field.
func (m *VersionMutation) SetPlistURL(s string) {
	m.plist_url = &s
}

// PlistURL returns the value of the "plist_url" field in the mutation.
func (m *VersionMutation) PlistURL() (r string, exists bool) {
	v := m.plist_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPlistURL returns the old "plist_url" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldPlistURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlistURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlistURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlistURL: %w", err)
	}
	return oldValue.PlistURL, nil
}

// ClearPlistURL clears the value of the "plist_url" field.
func (m *VersionMutation) ClearPlistURL() {
	m.plist_url = nil
	m.clearedFields[version.FieldPlistURL] = struct{}{}
}

// PlistURLCleared returns if the "plist_url" field was cleared in this mutation.
func (m *VersionMutation) PlistURLCleared() bool {
	_, ok := m.clearedFields[version.FieldPlistURL]
	return ok
}

// ResetPlistURL resets all changes to the "plist_url" field.
func (m *VersionMutation) ResetPlistURL() {
	m.plist_url = nil
	delete(m.clearedFields, version.FieldPlistURL)
}

// SetDescription sets the "description" field.
func (m *VersionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *VersionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *VersionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[version.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *VersionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[version.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *VersionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, version.FieldDescription)
}

// SetAccess sets the "access" field.
func (m *VersionMutation) SetAccess(s string) {
	m.access = &s
}

// Access returns the value of the "access" field in the mutation.
func (m *VersionMutation) Access() (r string, exists bool) {
	v := m.access
	if v == nil {
		return
	}
	return *v, true
}

// OldAccess returns the old "access" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldAccess(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccess: %w", err)
	}
	return oldValue.Access, nil
}

// ClearAccess clears the value of the "access" field.
func (m *VersionMutation) ClearAccess() {
	m.access = nil
	m.clearedFields[version.FieldAccess] = struct{}{}
}

// AccessCleared returns if the "access" field was cleared in this mutation.
func (m *VersionMutation) AccessCleared() bool {
	_, ok := m.clearedFields[version.FieldAccess]
	return ok
}

// ResetAccess resets all changes to the "access" field.
func (m *VersionMutation) ResetAccess() {
	m.access = nil
	delete(m.clearedFields, version.FieldAccess)
}

// SetAccessCode sets the "access_code" field.
func (m *VersionMutation) SetAccessCode(s string) {
	m.access_code = &s
}

// AccessCode returns the value of the "access_code" field in the mutation.
func (m *VersionMutation) AccessCode() (r string, exists bool) {
	v := m.access_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessCode returns the old "access_code" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldAccessCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessCode: %w", err)
	}
	return oldValue.AccessCode, nil
}

// ClearAccessCode clears the value of the "access_code" field.
func (m *VersionMutation) ClearAccessCode() {
	m.access_code = nil
	m.clearedFields[version.FieldAccessCode] = struct{}{}
}

// AccessCodeCleared returns if the "access_code" field was cleared in this mutation.
func (m *VersionMutation) AccessCodeCleared() bool {
	_, ok := m.clearedFields[version.FieldAccessCode]
	return ok
}

// ResetAccessCode resets all changes to the "access_code" field.
func (m *VersionMutation) ResetAccessCode() {
	m.access_code = nil
	delete(m.clearedFields, version.FieldAccessCode)
}

// SetStatus sets the "status" field.
func (m *VersionMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *VersionMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *VersionMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *VersionMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *VersionMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[version.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *VersionMutation) StatusCleared() bool {
	_, ok := m.clearedFields[version.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *VersionMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, version.FieldStatus)
}

// SetCreatedAt sets the "createdAt" field.
func (m *VersionMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *VersionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *VersionMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *VersionMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *VersionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *VersionMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *VersionMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *VersionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *VersionMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *VersionMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *VersionMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *VersionMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *VersionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddAppIDs adds the "app" edge to the App entity by ids.
func (m *VersionMutation) AddAppIDs(ids ...int) {
	if m.app == nil {
		m.app = make(map[int]struct{})
	}
	for i := range ids {
		m.app[ids[i]] = struct{}{}
	}
}

// ClearApp clears the "app" edge to the App entity.
func (m *VersionMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *VersionMutation) AppCleared() bool {
	return m.clearedapp
}

// RemoveAppIDs removes the "app" edge to the App entity by IDs.
func (m *VersionMutation) RemoveAppIDs(ids ...int) {
	if m.removedapp == nil {
		m.removedapp = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.app, ids[i])
		m.removedapp[ids[i]] = struct{}{}
	}
}

// RemovedApp returns the removed IDs of the "app" edge to the App entity.
func (m *VersionMutation) RemovedAppIDs() (ids []int) {
	for id := range m.removedapp {
		ids = append(ids, id)
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
func (m *VersionMutation) AppIDs() (ids []int) {
	for id := range m.app {
		ids = append(ids, id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *VersionMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
	m.removedapp = nil
}

// AddHistoryIDs adds the "histories" edge to the History entity by ids.
func (m *VersionMutation) AddHistoryIDs(ids ...int) {
	if m.histories == nil {
		m.histories = make(map[int]struct{})
	}
	for i := range ids {
		m.histories[ids[i]] = struct{}{}
	}
}

// ClearHistories clears the "histories" edge to the History entity.
func (m *VersionMutation) ClearHistories() {
	m.clearedhistories = true
}

// HistoriesCleared reports if the "histories" edge to the History entity was cleared.
func (m *VersionMutation) HistoriesCleared() bool {
	return m.clearedhistories
}

// RemoveHistoryIDs removes the "histories" edge to the History entity by IDs.
func (m *VersionMutation) RemoveHistoryIDs(ids ...int) {
	if m.removedhistories == nil {
		m.removedhistories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.histories, ids[i])
		m.removedhistories[ids[i]] = struct{}{}
	}
}

// RemovedHistories returns the removed IDs of the "histories" edge to the History entity.
func (m *VersionMutation) RemovedHistoriesIDs() (ids []int) {
	for id := range m.removedhistories {
		ids = append(ids, id)
	}
	return
}

// HistoriesIDs returns the "histories" edge IDs in the mutation.
func (m *VersionMutation) HistoriesIDs() (ids []int) {
	for id := range m.histories {
		ids = append(ids, id)
	}
	return
}

// ResetHistories resets all changes to the "histories" edge.
func (m *VersionMutation) ResetHistories() {
	m.histories = nil
	m.clearedhistories = false
	m.removedhistories = nil
}

// Where appends a list predicates to the VersionMutation builder.
func (m *VersionMutation) Where(ps ...predicate.Version) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VersionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Version).
func (m *VersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VersionMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.version != nil {
		fields = append(fields, version.FieldVersion)
	}
	if m.build != nil {
		fields = append(fields, version.FieldBuild)
	}
	if m.apk_size != nil {
		fields = append(fields, version.FieldApkSize)
	}
	if m.ipa_size != nil {
		fields = append(fields, version.FieldIpaSize)
	}
	if m.ipa_url != nil {
		fields = append(fields, version.FieldIpaURL)
	}
	if m.apk_url != nil {
		fields = append(fields, version.FieldApkURL)
	}
	if m.plist_url != nil {
		fields = append(fields, version.FieldPlistURL)
	}
	if m.description != nil {
		fields = append(fields, version.FieldDescription)
	}
	if m.access != nil {
		fields = append(fields, version.FieldAccess)
	}
	if m.access_code != nil {
		fields = append(fields, version.FieldAccessCode)
	}
	if m.status != nil {
		fields = append(fields, version.FieldStatus)
	}
	if m.createdAt != nil {
		fields = append(fields, version.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, version.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case version.FieldVersion:
		return m.Version()
	case version.FieldBuild:
		return m.Build()
	case version.FieldApkSize:
		return m.ApkSize()
	case version.FieldIpaSize:
		return m.IpaSize()
	case version.FieldIpaURL:
		return m.IpaURL()
	case version.FieldApkURL:
		return m.ApkURL()
	case version.FieldPlistURL:
		return m.PlistURL()
	case version.FieldDescription:
		return m.Description()
	case version.FieldAccess:
		return m.Access()
	case version.FieldAccessCode:
		return m.AccessCode()
	case version.FieldStatus:
		return m.Status()
	case version.FieldCreatedAt:
		return m.CreatedAt()
	case version.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case version.FieldVersion:
		return m.OldVersion(ctx)
	case version.FieldBuild:
		return m.OldBuild(ctx)
	case version.FieldApkSize:
		return m.OldApkSize(ctx)
	case version.FieldIpaSize:
		return m.OldIpaSize(ctx)
	case version.FieldIpaURL:
		return m.OldIpaURL(ctx)
	case version.FieldApkURL:
		return m.OldApkURL(ctx)
	case version.FieldPlistURL:
		return m.OldPlistURL(ctx)
	case version.FieldDescription:
		return m.OldDescription(ctx)
	case version.FieldAccess:
		return m.OldAccess(ctx)
	case version.FieldAccessCode:
		return m.OldAccessCode(ctx)
	case version.FieldStatus:
		return m.OldStatus(ctx)
	case version.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case version.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Version field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case version.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case version.FieldBuild:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuild(v)
		return nil
	case version.FieldApkSize:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApkSize(v)
		return nil
	case version.FieldIpaSize:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIpaSize(v)
		return nil
	case version.FieldIpaURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIpaURL(v)
		return nil
	case version.FieldApkURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApkURL(v)
		return nil
	case version.FieldPlistURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlistURL(v)
		return nil
	case version.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case version.FieldAccess:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccess(v)
		return nil
	case version.FieldAccessCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessCode(v)
		return nil
	case version.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case version.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case version.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Version field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VersionMutation) AddedFields() []string {
	var fields []string
	if m.addbuild != nil {
		fields = append(fields, version.FieldBuild)
	}
	if m.addapk_size != nil {
		fields = append(fields, version.FieldApkSize)
	}
	if m.addipa_size != nil {
		fields = append(fields, version.FieldIpaSize)
	}
	if m.addstatus != nil {
		fields = append(fields, version.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case version.FieldBuild:
		return m.AddedBuild()
	case version.FieldApkSize:
		return m.AddedApkSize()
	case version.FieldIpaSize:
		return m.AddedIpaSize()
	case version.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case version.FieldBuild:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBuild(v)
		return nil
	case version.FieldApkSize:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApkSize(v)
		return nil
	case version.FieldIpaSize:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIpaSize(v)
		return nil
	case version.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Version numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(version.FieldApkSize) {
		fields = append(fields, version.FieldApkSize)
	}
	if m.FieldCleared(version.FieldIpaSize) {
		fields = append(fields, version.FieldIpaSize)
	}
	if m.FieldCleared(version.FieldIpaURL) {
		fields = append(fields, version.FieldIpaURL)
	}
	if m.FieldCleared(version.FieldApkURL) {
		fields = append(fields, version.FieldApkURL)
	}
	if m.FieldCleared(version.FieldPlistURL) {
		fields = append(fields, version.FieldPlistURL)
	}
	if m.FieldCleared(version.FieldDescription) {
		fields = append(fields, version.FieldDescription)
	}
	if m.FieldCleared(version.FieldAccess) {
		fields = append(fields, version.FieldAccess)
	}
	if m.FieldCleared(version.FieldAccessCode) {
		fields = append(fields, version.FieldAccessCode)
	}
	if m.FieldCleared(version.FieldStatus) {
		fields = append(fields, version.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VersionMutation) ClearField(name string) error {
	switch name {
	case version.FieldApkSize:
		m.ClearApkSize()
		return nil
	case version.FieldIpaSize:
		m.ClearIpaSize()
		return nil
	case version.FieldIpaURL:
		m.ClearIpaURL()
		return nil
	case version.FieldApkURL:
		m.ClearApkURL()
		return nil
	case version.FieldPlistURL:
		m.ClearPlistURL()
		return nil
	case version.FieldDescription:
		m.ClearDescription()
		return nil
	case version.FieldAccess:
		m.ClearAccess()
		return nil
	case version.FieldAccessCode:
		m.ClearAccessCode()
		return nil
	case version.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Version nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VersionMutation) ResetField(name string) error {
	switch name {
	case version.FieldVersion:
		m.ResetVersion()
		return nil
	case version.FieldBuild:
		m.ResetBuild()
		return nil
	case version.FieldApkSize:
		m.ResetApkSize()
		return nil
	case version.FieldIpaSize:
		m.ResetIpaSize()
		return nil
	case version.FieldIpaURL:
		m.ResetIpaURL()
		return nil
	case version.FieldApkURL:
		m.ResetApkURL()
		return nil
	case version.FieldPlistURL:
		m.ResetPlistURL()
		return nil
	case version.FieldDescription:
		m.ResetDescription()
		return nil
	case version.FieldAccess:
		m.ResetAccess()
		return nil
	case version.FieldAccessCode:
		m.ResetAccessCode()
		return nil
	case version.FieldStatus:
		m.ResetStatus()
		return nil
	case version.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case version.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Version field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, version.EdgeUser)
	}
	if m.app != nil {
		edges = append(edges, version.EdgeApp)
	}
	if m.histories != nil {
		edges = append(edges, version.EdgeHistories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VersionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case version.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case version.EdgeApp:
		ids := make([]ent.Value, 0, len(m.app))
		for id := range m.app {
			ids = append(ids, id)
		}
		return ids
	case version.EdgeHistories:
		ids := make([]ent.Value, 0, len(m.histories))
		for id := range m.histories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeduser != nil {
		edges = append(edges, version.EdgeUser)
	}
	if m.removedapp != nil {
		edges = append(edges, version.EdgeApp)
	}
	if m.removedhistories != nil {
		edges = append(edges, version.EdgeHistories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VersionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case version.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case version.EdgeApp:
		ids := make([]ent.Value, 0, len(m.removedapp))
		for id := range m.removedapp {
			ids = append(ids, id)
		}
		return ids
	case version.EdgeHistories:
		ids := make([]ent.Value, 0, len(m.removedhistories))
		for id := range m.removedhistories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, version.EdgeUser)
	}
	if m.clearedapp {
		edges = append(edges, version.EdgeApp)
	}
	if m.clearedhistories {
		edges = append(edges, version.EdgeHistories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VersionMutation) EdgeCleared(name string) bool {
	switch name {
	case version.EdgeUser:
		return m.cleareduser
	case version.EdgeApp:
		return m.clearedapp
	case version.EdgeHistories:
		return m.clearedhistories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VersionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Version unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VersionMutation) ResetEdge(name string) error {
	switch name {
	case version.EdgeUser:
		m.ResetUser()
		return nil
	case version.EdgeApp:
		m.ResetApp()
		return nil
	case version.EdgeHistories:
		m.ResetHistories()
		return nil
	}
	return fmt.Errorf("unknown Version edge %s", name)
}
